module FoldFunctions where

import Data.List

-- Правая свёртка ---------------------------------------------------------

foldr' :: (a -> b -> b) -> b -> [a] -> b
foldr' _ acc []      = acc
foldr' f acc (x:xs)  = x `f` foldr' f acc xs

-- Правая свёртка реализует часто повторяющуюся схему рекурсии
-- при операциях над списками, например, рассмотрим рекурсивные реализации
-- для суммы списков и конкатенации списков, а затем реализуем их с foldr

sumList :: Num a => [a] -> a
sumList []      = 0
sumList (x:xs)  = x + sumList xs

sumList' :: Num a => [a] -> a
sumList' = foldr' (+) 0

concatList :: [[a]] -> [a]
concatList []        = []
concatList (xs:yss)  = xs ++ concatList yss

concatList' :: [[a]] -> [a]
concatList' = foldr' (++) []

{-
Можно проиллюстрировать последовательность редукций при правой свёртке
на следующем примере. Следует учесть, что показанная ниже последовательность
рекупсивных вызовов не совсем корректна, так как головным редексом
является `f` в котором также могут быть вычисления. Но будем считать, что
функция f неопределена:

foldr f acc 1:2:3:[]
>> 1 `f` (foldr f acc 2:3:[])
>> 1 `f` (2 `f` (foldr f acc 3:[]))
>> 1 `f` (2 `f` (3 `f` (foldr f acc [])))
>> 1 `f` (2 `f` (3 `f` acc))

То есть список как бы "пересобирается" справа, начиная со значения acc,
но вместо конструктора (:) подставляется функция f
-}

-- Левая свёртка и ее сравнение с правой -------------------------------------

{-
В отличие от правой, в левой свёртке инициализирущее значение помещается 
как бы в начало списка и далее каждый элемент списка посредством функции
связывается с новым значением инициализатора слева направо, то есть, 
используя пример выше:
foldl f acc 1:2:3:[]
>> (((foldl acc []) `f` 1) `f` 2) `f` 3  то есть:
>> ((acc `f` 1) `f` 2) `f` 3
Или в функциональном стиле:
f (f (f acc 1) 2) 3

Отличие типа левой свертки, соотвественно, в типе сворачивающей функции - 
элементы списка в ней находятся на втором месте, а инициализириющее значение
на первом.

Реализация левой свёртки, в отличие от правой, рекурсивный вызов просходит
сразу же на хвосте списка, реализуется хвостовая рекурсия.

* Использовано название foldl'', так как функция foldl' есть в импортированном
пакете Data.List
-}
foldl'' :: (b -> a -> b) -> b -> [a] -> b
foldl'' _ acc []      = acc
foldl'' f acc (x:xs)  = foldl'' f (f acc x) xs

{-
Распишем список рекурсивных вызовов на аналогичном предыдущему примере:
 foldl f acc 1:2:3:[]
 >> foldl f (f acc 1) 2:3:[]
 >> foldl f (f (f acc 1) 2) 3:[]
 >> foldl f (f (f (f acc 1) 2) 3) []
 и на пустом списке возвращаем acc:
 >> f (f (f (f acc 1) 2) 3)

Из реализации функции видна ее неэффективность - в результате
рекурсивных вызовов на большом списке в acc накапливается столь же большое
отложенное вычисление (thunk). В Data.List есть более строгая реализация -
foldl', которой и рекомендуется пользоваться
-}

{-
Рассмотрим строгую версию левой свёртки, реализованную в пакете Data.List
под названием foldr'.
Так как отложенные вычисления накапливаются в acc, необходимо форсировать
эти вычисления до WHNF с помощью функции seq, для чего перепишем предыдущию реализацию,
используя where и форсируем вычисление acc
-}
foldl''' :: (b -> a -> b) -> b -> [a] -> b
foldl''' _ acc []      = acc
foldl''' f acc (x:xs)  = acc' `seq` foldl''' f acc' xs
  where acc' = f acc x

{-
Разницу в работе левой и правой свёртки можно также
проиллюстрировать на неассоциативной функции, например (-)

foldr (-) 1 [1,2,3] --> 1 - (2 - (3 - 1)) = 1
foldl (-) 1 [1,2,3] --> ((1 - 1) - 2) - 3 = -5
-}

-- Поведение правой и левой свёртки на беесконечных списках -----------------------

{-
Обратившись к определениям foldl и foldr можно отметить, что при работе с
бесконечными списками, первое уравнение обеих функций никогда не будет работать -
список никогда не будет пустым.
Второе уравнение левой свёртки содержит рекурсивный вызов самой себя и при работе
с бесконечным списком, такой вызов будет происходить постоянно и функция
будет расходящейся, результат не может быть достигнут.
В правой же свёртке в рекуривных вызовах работает функция f - она является
головным редексом. Функция f имеет два аргумента,
второй из которых снова рекурсивный вызов. И в случаях, когда функция f
оказывается нестрогой по второму аргументу может быть получен результат и на
бесконечном списке.

Для иллюстрации используем функцию логического "или" (||) и функцию any,
определённую для конечного списка и возращающую True если в списке есть значение,
возвращающее True для предиката p, и False в противном случае.

* Используем (||| для независимого определения "или")
-}
(|||) :: Bool -> Bool -> Bool
False ||| x  = x
True  ||| _  = True

-- Реализуем функцию any с помощью foldr', определённой выше
any' :: (a -> Bool) -> [a] -> Bool
any' p = foldr' (\x acc -> p x ||| acc) False
{- | Данная реализация функции any способна работать с бесконечными списками.
     Её логичным прведением будет работа со списком (в том числе бесконечным)
     до тех пор пока не будет выполнено условие предиката - и тогда она вернет True.
     В случае если в бесконечном списке не будет значений соотвествующих предикату,
     она конечно же разойдется.

     Для понимания такого поведения нужно взглянуть на реализацию лямбды и определение
     для "или", данное выше - в случае, когда предикат даст True (p x), логическое 
     "или" проигнорирует второй аргумент (см. второе уравнение в определении (|||))
     и будет получен результат True, а вычисление списка прекратится.
     any' (> 1000) [1..]
     >> True
-}

{- Используя кортежи в качестве аккумулирущего значения можно реализовать 
   накопления значений вычисляемых различными функциями свёртки, то есть, по сути,
   передавать несколько функций сверки в foldr или foldl.

   Для примера реализуем функцию, накапливающую сумму и произведение списка
   (без разумной обработки пустого списка).
-}
sum'prod :: Num a => [a] -> (a, a)
sum'prod = foldr' (\x (s, p) -> (s + x, p * x)) (0, 1)

-- Функции, родственные свёрткам -------------------------------------------------

{- Для множества алгоритмов сложно определить корректное поведение на пустом 
списке. Примером могут служить нахождение максимума и минимума списка. Для
решения подобных задач в стандартной библиотеке определены foldr1 и foldl1, 
имеющие другое определение и поведение - на пустом списке они возвращают ошибку
и в качестве инициализатора правая свёртка foldr1 использует последний элемент,
списка, а левая foldl1 - соответственно последнее.

Так как в качестве инициализатора используются элементы списка, то тип функции
более мономорфен (см. реализации ниже). Определим их "со штрихом".
Первым уравнением мы приравниваем значение функции соотвествующему элементу
(последнему - для правой и первому - для левой), в последнем возвращаем ошибку
в случае пустого списка.

* В Data.List также как и в прошлый раз определена оптимизорованная с помощью
seq функция foldl1' - поэтому используем два штриха.
-}
foldr1' :: (a -> a -> a) -> [a] -> a
foldr1' _ [x]     = x
foldr1' f (x:xs)  = x `f` foldr1' f xs
foldr1' _ []      = error "foldr1: EmptyList"

-- в случае левой свертки мы можем вызывать функцию нерекурсивно,
-- используя foldl, так инициализатор известен - это x - 
-- первый элемент списка
foldl1'' :: (a -> a -> a) -> [a] -> a
foldl1'' _ [x] = x
foldl1'' f (x:xs) = foldl f x xs
foldl1'' _ [] = error "foldl1: EmptyList"

-- Используя эти функции можно, например определить функцию
-- maximum для списка как:
maximum' :: Ord a => [a] -> a
maximum'= foldr1' max

-- Функции сканирования, сохраняющие результаты шагов свёртки в листе ---------
-- Данные функции определены в пакете Data.List

-- Левое сканирование ---------------------------------------------------------

{- Рассмотрим функцию левого сканирования scanl.
   Функция левой свёртки foldl возвращает через некоторое количество шагов
   редукции такую конструкцию:
   foldl f acc [1,2,3] --> ((acc `f` 1) `f` 2) `f` 3
   Функция scanl в таком случае должна вернуть нам список всех значений acc,
   начиная с инициализирующего и заканчивая конечным результатом работы foldl:
   [acc, acc `f` 1, (acc `f` 1) `f` 2, ((acc `f` 1) `f` 2) `f` 3]
   Реализуем:
   * Используем два штриха, так как строгая версия scanl - scanl' уже 
   определена в Data.List
-}
scanl'' :: (b -> a -> b) -> b -> [a] -> [b]
scanl'' _ acc []      = [acc]
scanl'' f acc (x:xs)  = acc : scanl'' f (acc `f` x) xs

-- Список факториалов с помощью scanl''
factList :: [Integer] -> [Integer]
factList = scanl'' (*) 1
-- factList [1..5]   >> [1,1,2,6,24,120]

{- В отличие от левой свёртки, левое сканирование может работать
   с бесконечными списками, так как результирующий список конструируется 
   на каждом шаге рекурсии. 

   Например, убедимся, что сумма ряда обратных факториалов
   стремится к е.
-}

-- Определим функцию, считающую частичные суммы ряда чисел:
partSum :: Num a => [a] -> [a]
partSum = scanl (+) 0
-- λ: take 10 . partSum $ [1..]
-- >> [0,1,3,6,10,15,21,28,36,45]
-- Напишем функцию, генерирующую бесконечный список обратных факториалов
inverseFacts :: (Floating a, Enum a) => [a]
inverseFacts = map (**(-1)) . scanl (*) 1 $ [1..]
-- убедимся, что уже на 10 значении, ряд хорошо сходится к e:
-- λ: take 10 . partSum $ inverseFacts
-- >> [0.0,1.0,2.0,2.5,2.6666666666666665,2.708333333333333,2.7166666666666663,
--     2.7180555555555554,2.7182539682539684,2.71827876984127]

-- Правое сканирование --------------------------------------------------------

{-  Аналогичным образом можно определить и функцию правого сканирования.
    В отличие от правой свёртки и левого сканирования, правое плохо работает
    на бесконечных списках, поэтому данная функция используется реже.
-}
scanr' :: (a -> b -> b) -> b -> [a] -> [b]
scanr' _ acc [] = [acc]
scanr' f acc (x:xs) = (x `f` z) : zs
  where zs@(z:_) = scanr' f acc xs

{- Результирующий список будет собираться с конца - конечным значением будет
   значение аккумулирующего значения acc.

   Вспомним, что последовательность редукций для правой свёртки будет выглядеть
   таким образом (с оговоркой, что f не специфицирована и не работает):
   foldr f acc [1,2,3] --> 1 `f` (2 `f` (3 `f` acc))
   То есть результатом работы функции scanr, которую мы определили выше будет:
   [1 `f` (2 `f` (3 `f` acc)), 2 `f` (3 `f` acc), 3 `f` acc, acc]
   Становится понятно, почему она плохо работает с бесконечными списками -
   первый элемент списка может вычислятся бесконечно без дополнительных
   ухищрений.
   λ: take 10 $ scanr' (+) 0 [1..]
   >> *** Exception: stack overflow
-}

-- Функция обратная свёртке - развертка unfold --------------------------------

{- Функция, генерирующая следующий элемент списка долна возвращать пару,
   в которой будут храниться значение списка и новое инициализирующее значение.
   Если функция будет типа b -> a, то можно создать только список из одинаковых 
   элементов.
-}

unfold' :: (b -> (a, b)) -> b -> [a]
unfold' f  ini = 
  let (x, ini') = f ini
  in x:unfold' f ini'
 {- λ: take 5 . unfold' (\x -> (x, x^2)) $ 2
    >> [2,4,16,256,65536]
 -}

{- Реализуем функцию iterate c помощью unfold'
   Результатом работы iterate должен быть бесконечный список вида:
   [x, f x, f (f x), f (f (f x)) ...]

   * В Data.List есть функция iterate', используем '' и '''
-}
-- рекурсивная реализация:
iterate'' :: (a -> a) -> a -> [a]
iterate'' f x = x : iterate'' f (f x)

-- реализация с unfoldr:
iterate''' :: (a -> a) -> a -> [a]
iterate''' f = unfold' (\x -> (x, f x))
{- λ: take 5 . iterate''' (^2) $ 2
   >> [2,4,16,256,65536]
-}

-- Базовая информация о типе данных Maybe --------------------------------
{- Тип Maybe необходим чтобы расширить функциональность unfold - 
   возможность генерировать не только бесконечные, но и конечные списки.

   Тип Maybe по сути расширяет любой тип данных дополнительным значением
   Nothing, то есть выражает идею отсутствующего значения.
   Если же значение есть, то оно упаковывается в контейнер Just откуда
   его можно извлечь с помощью pattern matching.
   λ: :t Just True
   >> Just True :: Maybe Bool

   Для иллюстрации используем функции find и lookup, определенные в
   пакете Data.List.
   - find ищет первое включение в лист значения, соотвествующее предикату
     и возвращает его в контейнере Just, либо возвращает Nothing
   - lookup ищет значение по "ключу" в ассоциативном списке (списке пар),
     считая ключом первое значение пары и возвращает "значение" - второй
     элемент пары, упакованный в Just или Nothing. Требования уникальности
     ключей у ассоциативного списка нет.
   
   find (\x -> x > 2 && x < 5) [6,5,4,3,2]
   >> Just 4
   λ: lookup 2 [(1,5),(2,42),(2,43)]
   >> Just 42
-}


