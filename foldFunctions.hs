module FoldFunctions where

import Data.List

-- Правая свёртка ---------------------------------------------------------
foldr' :: (a -> b -> b) -> b -> [a] -> b
foldr' _ acc []      = acc
foldr' f acc (x:xs)  = x `f` foldr' f acc xs

-- Правая свёртка реализует часто повторяющуюся схему рекурсии
-- при операциях над списками, например, рассмотрим рекурсивные реализации
-- для суммы списков и конкатенации списков, а затем реализуем их с foldr

sumList :: Num a => [a] -> a
sumList []      = 0
sumList (x:xs)  = x + sumList xs

sumList' :: Num a => [a] -> a
sumList' = foldr' (+) 0

concatList :: [[a]] -> [a]
concatList []        = []
concatList (xs:yss)  = xs ++ concatList yss

concatList' :: [[a]] -> [a]
concatList' = foldr' (++) []

{-
Можно проиллюстрировать последовательность редукций при правой свёртке
на следующем примере. Следует учесть, что показанная ниже последовательность
рекупсивных вызовов не совсем корректна, так как головным редексом
является `f` в котором также могут быть вычисления. Но будем считать, что
функция f неопределена:

foldr f acc 1:2:3:[]
>> 1 `f` (foldr f acc 2:3:[])
>> 1 `f` (2 `f` (foldr f acc 3:[]))
>> 1 `f` (2 `f` (3 `f` (foldr f acc [])))
>> 1 `f` (2 `f` (3 `f` acc))

То есть список как бы "пересобирается" справа, начиная со значения acc,
но вместо конструктора (:) подставляется функция f
-}

-- Левая свёртка и ее сравнение с правой -------------------------------------

{-
В отличие от правой, в левой свёртке инициализирущее значение помещается 
как бы в начало списка и далее каждый элемент списка посредством функции
связывается с новым значением инициализатора слева направо, то есть, 
используя пример выше:
foldl f acc 1:2:3:[]
>> (((foldl acc []) `f` 1) `f` 2) `f` 3  то есть:
>> ((acc `f` 1) `f` 2) `f` 3
Или в функциональном стиле:
f (f (f acc 1) 2) 3

Отличие типа левой свертки, соотвественно, в типе сворачивающей функции - 
элементы списка в ней находятся на втором месте, а инициализириющее значение
на первом.

Реализация левой свёртки, в отличие от правой, рекурсивный вызов просходит
сразу же на хвосте списка, реализуется хвостовая рекурсия.

* Использовано название foldl'', так как функция foldl' есть в импортированном
пакете Data.List
-}
foldl'' :: (b -> a -> b) -> b -> [a] -> b
foldl'' _ acc []      = acc
foldl'' f acc (x:xs)  = foldl'' f (f acc x) xs

{-
Распишем список рекурсивных вызовов на аналогичном предыдущему примере:
 foldl f acc 1:2:3:[]
 >> foldl f (f acc 1) 2:3:[]
 >> foldl f (f (f acc 1) 2) 3:[]
 >> foldl f (f (f (f acc 1) 2) 3) []
 и на пустом списке возвращаем acc:
 >> f (f (f (f acc 1) 2) 3)

Из реализации функции видна ее неэффективность - в результате
рекурсивных вызовов на большом списке в acc накапливается столь же большое
отложенное вычисление (thunk). В Data.List есть более строгая реализация -
foldl', которой и рекомендуется пользоваться
-}

